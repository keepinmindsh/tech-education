# 클래스 체계 

클래스를 정의하는 표준 자바 관례에 따르면, 가장 먼저 변수 목록이 나온다. 정적 공개 상수가 있다면 맨 처음에 나온다. 다음으로 정적 비공개 변수가 나오며, 이어서 비공개 인스턴스 변수가 나온다.

# 클래스 캡슐화 

캡슐화 : 캡슐화를 풀어주는 결정은 언제나 최후의 수단이다.

# 클래스에 부여하는 책임

- 책임이 너무 많은 것  
- 클래스 이름은 해당 클래스 책임을 기술 해야 한다.  
- 클래스의 함수개수가 작은것 보다 포함되어 있는 함수들이 하나의 책임을 기준으로 움직이는지가 중요하다.  
- 작명은 클래스를 줄이는 첫번째 관문이다.  
- 간결한 이름이 떠오르지 않는다면 필경 클래스 책임이 너무 많아서다.  

### 규칙 

- Class 설명 규칙

클래스에 대한 설명은 만일(“if”), 그리고(“and”), -(하)며(“or”), 하지만(“but”) 을   
사용하지 않고서 25단어 내외로 가능해야 한다.  

### 단일 책임의 원칙 ( SRP ) 

- 클래스나 모듈을 변경할 이유가 하나, 단하나 뿐이어야 한다는 원칙이다. 
- SRP는 ‘**책임**’이라는 개념을 정의하며 적절한 클래스 크기를 제시한다.  
- 깨끗하고 체계적인 소프트웨어에서는 큰 클래스 몇개가 아니라 작은 클래스 여럿으로 이루어진 시스템이 더 바람직하다.   
- 작은 클래스는 각자 맡은 책임이 하나며, 변경할 이유가 하나며, 다른 작은 클래스와 협력해 시스템에 필요한 동작을 수행한다.

# 응집도 ( Cohesion ) 

**이상적인 모듈화는 결합도는 낮을 수록, 응집도는 높을 수록 유지보수성이 높다라고 할 수 있다.**  

응집도는 한 모듈 내에 존재하는 함수, 데이터 등의 구성 요소들 사이의 밀접한 정도를 나타낸다. 응집도가 높은 모듈은 하나의 모듈 안에 필요한 함수나 
데이터와 같은 구성 요소들이 똘똘 뭉쳐서 존재한다.  

이를 클래스로 풀면,  

- 클래스는 인스턴스 변수의 수가 작아야 한다.  
- 각 클래스 메서드는 클래스 인스턴스 변수를 하나 이상 사용해야 한다.  
- 일반적으로 메서드가 변수를 더 많이 사용할 수록 메서드와 클래스는 응집도가 높다.   
- 응집도가 높다는 말은 클래스에 속한 메서드와 변수가 서로 의존하며 논리적으로 묶인다는 이야기다.

큰 함수를 작은 함수/클래스 여럿으로 쪼개다 보면 종종 작은 클래스 여럿으로 쪼갤 기회가 생긴다.   
그러면서 프로그램에 점점 더 체계가 잡히고 구조가 투명해진다.  
단위가 큰 하나의 함수를 여러 함수로 의미있게 분리해야 한다.  

- 나누는 방법 
  - 리팩터링한 프로그램은 좀더 길고, 서술적인 변수 이름을 사용한다. 
  - 리팩터링한 프로그램은 코드에 주석을 추가하는 수단으로 함수 선언과 클래스 선언을 활용한다. 
  - 가독성을 높이고자 공백을 추가하고, 형식을 맞추었다.

##### 응집도가 낮은 클래스의 문제점

- 이해하기 어려움
- 재사용하기 힘듦
- 유지보수가 어려움
- 다른 클래스의 변화에 민감함

### 변경으로부터 격리

요구사항은 변하기 마련이며, 따라서 코드도 변하기 마련이다.  
우리는 인터페이스와 추상클래스를 사용해 구현이 미치는 영향을 격리한다.

# 변경하기 쉬운 클래스 

대다수 시스템은 지속적인 변경이 가해진다. 그리고 뭔가 변경할 때마다 시스템이 의도대로 동작하지 않을
위험이 따른다. 깨끗한 시스템은 클래스를 채계적으로 정리해 변경에 수반하는 위험을 낮춘다.  
깨끗한 시스템은 체계적으로 정리해 변경에 수반하는 위험을 낮춘다.  

### **클래스를 극도로 단순하게 만들것**

객체지향 설계에서의 또 다른 행심 원칙인 OCP도 지원한다.  
OCP란 클래스는 확장에 개방적이고 수정에 폐쇄적이어야 한다는 원칙이다.  
우리가 재구성한 클래스는 파생 클래스를 생성하는 방식으로 새기능에 개방적인 동시에 기능에 대한 수정시 변경에 대해서는 다른 클래스에 영향을 미치지 않는 방식으로 수정에 폐쇄적이다.

OCP - 확장에 개방적이지만, 수정에 폐쇄적이어야 하는 법칙   
DIP - 클래스가 상세한 구현이 아니라 추상화에 의존해야 한다는 것

***

# 객체지향 설계 5대 법칙 - SOLID 

### SRP - 단일 책임의 원칙

***

##### “객체는 하나의 책임만을 맡아야 한다”

- SRP 는 대상이 함수나 메소드가 아닌 객체라는 점에 주목할 것
- 객체는 둘 이상의 책임을 갖지 않는 형태를 가져야 함
- 즉, 두 개 이상의 메소드가 프로퍼티를 가졌을 때 책임이 그 수만큼 늘어나게 된다면 과감하게 분리
- SRP 는 하나의 객체가 두개의 책임을 가지는 것 만큼이나 두 개의 객체가 하나의 책임을 나누는 것에 주의를 기울여야 함
- 단일 요구 사항의 변경으로 둘 이상의 객체가 변경을 요하는 상황에 처한다면 책임이 나뉘었다고 판단하고, 하나의 객체가 온전히 책임을 다 가질 수 있도록 해주어야 함.
- 클래스에 있어서 책임이란 클래스에 할당된 비즈니스 로직에 대한 요구를 말한다.
File 클래스는 파일 처리라는 책임을 맡고 있고, String 클래스는 문자열 표현과 처리라는 책임을 맡고 있다.
단일 책임의 원칙은 하나의 클래스는 하나의 책임만을 맡아야 한다는 원칙이며,
이는 ‘높은 응집도와 낮은 결합도 원칙’을 지킬 수 있도록 해주는 세부 원칙이라 할 수 있다.  

###### 여기서의 책임은 순수하게 하나에 대한 책임을 이야기한다.  

- 억지로 책임을 나누지 말아야 한다.
**책임은 하나의 변화의 축이며, 하나의 요구 사항 변경은 하나의 책임**을 직시하는 경우가 많다.
책임의 입자도가 매우 세밀하다면 변경에 대한 영역이 그만큼 커지게 된다.
변화가 예측되는 곳, 변화에 효율적으로 대응할 수 있는 크기에서 책임을 할당하는 것이 좋다.
- 하나는 온전한 하나이어야 한다.
하나의 클래스가 여러가지 책임을 맡는 것도 곤란하지만, 하나의 책임을 여러 클래스로 분할하여 할당하는 것도 곤란하다.
전자는 클래스가 여러 원인에 의해 변경되도록 하며, 후자는 하나의 원인으로 인해 여러 클래스가 변경되도록 한다.
- 확실하게 책임에 대한 구현을 은닉해 놓았다면 한 클래스에 두 개의 책임이 혼재 하더라도 변경으로 외부에 미치는 영향을 최소화 할 수 있다.

### OCP - 개방 폐쇄의 원칙 

***

###### “모듈은 기존 모듈의 내부 변경에는 닫혀 있어야 하고, 새로운 확장(새로운 자식 클래스 C 의 출현과 같은 )에는 열려있어야 한다.”

![](https://keepinmindsh.github.io/lines/assets/img/solid_ocp.png){: .align-center}

이 때 변경의 확산을 막아 주고 확장의 포인트가 되는 인터페이스가 새로운 요구 사항을 반영할 수 있을 만큼 견고하게 설계되어 있어야 한다.
이런 구조는 변경은 확산되지 않고, 확장에는 열려있는 것이야 말로 유연하고 변화를 수용할 수 있는 구조를 보장한다.

- 유연성
  - OPEN : 클래스 수직 관계(is-a)에서는 열려있어야 한다. 기반 클래스에서 파생 클래스로 확장
  - CLOSE : 클래스 수평 관계(has-a)에서는 유연해야 한다. 즉 영향을 받지 않아야 한다.
- 어떻게 ? 추상화 도입 > 추상클래스, 인터페이스
  - STEP 1 : 클래스 사이에서 존재하는 공통 적인 속성을 추출
  - STEP 2 : 추출된 속성은 하나의 인터페이스 또는 추상 클래스로 디자인 하기
  - STEP3 : 이렇게 디자인된 인터페이스 또는 추상 클래스 상속하기

### LSP - 리스코프 치환 원칙

***
  
###### “기반 클래스는 파생 클래스로 대체 가능해야 한다.”

![](https://keepinmindsh.github.io/lines/assets/img/solid_lsp.png){: .align-center}

- 자식 타입들은 부모 타입들이 사용되는 곳에 대체될 수 있어야 한다.
- LSP는 잘 디자인 된 상속에 관한 내용입니다.
부모 클래스를 상속할 때, 부모 클래스가 사용되는 것은 아무 문제 없이 자식 클래스도 사용할 수 있어야 합니다.
그렇지 않으면 상속을 잘못 사용하고 있는 것입니다.
상속 관계에서 부모와 자식 간에는 is-a 관계가 성립해야 한다.
이 말은 곧 자식이 부모의 유산 중 일부를 거부하면 안된다는 것을 의미한다.
자식의 구현이 행동하는 방식은 다를 수 있지만,
제공하는 서비스 자체가 다르다면 is-a 관계가 성립할 수 없기 때문이다.
LSP는 올바른 상속 구조가 갖추어야 할 특성을 가이드 해주며 OCP 의 기반이 된다.


### ISP - 인터페이스 분리 원칙

***
  
###### “클라이언트에 특화된 여러 개의 인터페이스가 하나의 범용 인터페이스보다 낫다”


- 파생 클래스 입장에서 사용할 때 100% 구현할 수 있는 인터페이스만 사용해야 한다.
- 인터페이스를 함수를 통해 사용할 때 자신의 목적에 맞게 사용해야 한다.


 상위 서비스 클래스는 클라이언트 A, B에 서비스를 제공하고 있지만 각각의 클라이언트가 서비스를 사용하는 메소드군이 서로 다르다.
이 때 클라이언트 A에 서비스 클래스의 method GroupB( ) 메소드들은 불필요한 메소드가 된다.
즉 노출되지 않아도 될 methodGroupB( ) 메소드들이 클라이언트 A에 노출됐다.
이런 경우 변경이 필요하다.
왜냐하면 클라이언트 A에 특화된 메소드들만 제공하게 되면 클라이언트 A와 methodGroupA( ) 간의
응집도는 높아지고 methodGroupB( ) 와의 결합도는 낮아지므로,
methodGroupB( )의 변경에서 클라이언트 A를 고립시킬 수 있기 때문이다.

### DIP - 의존관계역전 원칙

***

###### “클라이언트는 구체 클래스가 아닌 인터페이스 추상 클래스에 의존해야 한다”  

구체 클래스(구현)은 인터페이스 보다 변하기 쉽다.
따라서 클라이언트는 변화에 민감한 구체 클래스를 상대하기 보다 인터페이스를 정의 해서,
구현이 변화된다 하더라도 변화의 충격에서 자유로울 수 있도록 클라이언트를 구체 클래스와 분리 시켜야 한다.
인터페이스를 이용해서 구현의 세부 사항을 은닉할 수 있다.
인터페이스의 경우 향후 변화가 발생했을 때 객체 생성 부분만 변경해 주면 된다.
